import fs from 'fs';
import path from 'path';
import { MCPJson, Action } from '../types';

/**
 * Generates an MCP server TypeScript file from the given MCP JSON
 */
export function generateMcpServer(mcpJson: MCPJson, outputPath: string, apiBaseUrl: string): void {
  const serverCode = `
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// Server configuration
const server = new McpServer({
  name: ${JSON.stringify(mcpJson.name)},
  version: ${JSON.stringify(mcpJson.version)},
  description: ${JSON.stringify(mcpJson.description)}
});

// Using function registry pattern for better maintainability and testing
${generateToolDefinitions(mcpJson, apiBaseUrl)}

// Register all tools with the server
toolDefinitions.forEach(tool => 
  server.tool(
    tool.name,
    tool.description,
    tool.schema,
    tool.handler
  )
);

// Start the server with stdio transport for Claude Desktop
server.registerTransport(new StdioServerTransport({ input: process.stdin, output: process.stdout }));
process.stdin.resume();
`;

  fs.writeFileSync(path.resolve(outputPath, 'mcp-server.ts'), serverCode.trim());
  console.log(`âœ… Generated MCP server at ${path.join(outputPath, 'mcp-server.ts')}`);
  
  // We don't need to generate sample handlers here anymore since they're generated by the handlers generator
}

/**
 * Generates tool definitions array using the function registry pattern
 */
function generateToolDefinitions(mcpJson: MCPJson, apiBaseUrl: string): string {
  if (!mcpJson.actions || mcpJson.actions.length === 0) {
    return 'const toolDefinitions = [];';
  }

  const toolDefs = mcpJson.actions.map((action: Action) => {
    // Create Zod schema for action parameters
    const paramsSchema = action.params 
      ? Object.entries(action.params).map(([name, type]) => {
          return `${name}: z.${mapTypeToZod(type)}.describe(${JSON.stringify(name)})`;
        }).join(',\n    ')
      : '';

    return `
  // ${action.description || action.action}
  {
    name: ${JSON.stringify(action.action)},
    description: ${JSON.stringify(`${action.action} (${action.method} ${action.path})`)},
    schema: {
      ${paramsSchema}
    },
    handler: async (args) => {
      ${generateToolFunctionBody(action, apiBaseUrl)}
    }
  }`;
  }).join(',\n');

  // Add getState tool if state schema is available
  const stateToolDef = mcpJson.stateSchema ? `
  // Get current state
  {
    name: "getState",
    description: "Get the current state of the system",
    schema: {},
    handler: async () => {
      try {
        const res = await fetch(\`${apiBaseUrl}${mcpJson.stateSchema.endpoint || ''}\`);
        const data = await res.json();
        return {
          content: [{ type: "text", text: JSON.stringify(data, null, 2) }]
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: \`Error: \${error.message}\` }]
        };
      }
    }
  }` : '';

  return `const toolDefinitions = [${toolDefs}${stateToolDef ? `,${stateToolDef}` : ''}
];

// Try to load custom handlers from handlers/ directory
try {
  // This allows users to add new tools or override existing ones 
  // by creating files in the handlers/ directory
  const fs = require('fs');
  const path = require('path');
  
  const handlersDir = path.resolve(__dirname, 'handlers');
  if (fs.existsSync(handlersDir)) {
    fs.readdirSync(handlersDir)
      .filter(file => file.endsWith('.js') || file.endsWith('.ts'))
      .filter(file => file !== 'index.js' && file !== 'index.ts' && !file.startsWith('README'))
      .forEach(file => {
        const handlerName = path.basename(file, path.extname(file));
        try {
          const handlerModule = require(\`./handlers/\${handlerName}\`);
          
          // Check if this handler is replacing an existing one or adding a new one
          const existingToolIndex = toolDefinitions.findIndex(tool => tool.name === handlerName);
          
          if (existingToolIndex >= 0 && handlerModule.handler) {
            // Replace the handler but keep the name, description and schema
            console.log(\`Using custom handler for \${handlerName}\`);
            toolDefinitions[existingToolIndex].handler = handlerModule.handler;
            
            // Update schema if provided
            if (handlerModule.paramSchema) {
              toolDefinitions[existingToolIndex].schema = handlerModule.paramSchema;
            }
          } else if (handlerModule.handler) {
            // Add new tool
            console.log(\`Adding custom tool: \${handlerName}\`);
            toolDefinitions.push({
              name: handlerName,
              description: \`Custom tool: \${handlerName}\`,
              schema: handlerModule.paramSchema || {},
              handler: handlerModule.handler
            });
          }
        } catch (error) {
          console.error(\`Error loading handler \${handlerName}: \${error.message}\`);
        }
      });
  }
} catch (error) {
  console.error(\`Error scanning for custom handlers: \${error.message}\`);
}`;
}

/**
 * Maps OpenAPI/MCP parameter types to Zod validators
 */
function mapTypeToZod(type: string): string {
  switch (type.toLowerCase()) {
    case 'integer':
      return 'number()';
    case 'number':
      return 'number()';
    case 'boolean':
      return 'boolean()';
    case 'array':
      return 'array(z.any())';
    case 'object':
      return 'record(z.any())';
    default:
      return 'string()';
  }
}

/**
 * Generates the URL with path parameters for an action
 */
function generateActionUrl(action: Action, apiBaseUrl: string): string {
  // Replace path parameters with template strings
  const urlPath = action.path.replace(/{([^}]+)}/g, '${args.$1}');
  return `\`${apiBaseUrl}${urlPath}\``;
}

/**
 * Generates the function body for the server's tool implementation
 */
function generateToolFunctionBody(action: Action, apiBaseUrl: string): string {
  // Get path parameters from the URL path
  const pathParams = (action.path.match(/{([^}]+)}/g) || [])
    .map(param => param.substring(1, param.length - 1));
  
  // Get query parameters (parameters that aren't in the path)
  const queryParams = action.params 
    ? Object.keys(action.params).filter(param => !pathParams.includes(param))
    : [];
  
  // Create base URL with proper slash handling
  const baseUrl = apiBaseUrl.endsWith('/') ? apiBaseUrl.slice(0, -1) : apiBaseUrl;
  const path = action.path.startsWith('/') ? action.path : `/${action.path}`;
  const formattedPath = path.replace(/{([^}]+)}/g, '${args.$1}');
  
  // For GET requests
  if (action.method === 'GET') {
    if (queryParams.length > 0) {
      return `try {
        const queryParams = new URLSearchParams();
${queryParams.map(param => `        queryParams.append("${param}", String(args.${param}));`).join('\n')}
        const res = await fetch(\`${baseUrl}${formattedPath}\${queryParams.toString() ? \`?\${queryParams.toString()}\` : ''}\`);
        const data = await res.json();
        return {
          content: [{ type: "text", text: JSON.stringify(data, null, 2) }]
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: \`Error: \${error.message}\` }]
        };
      }`;
    } else {
      return `try {
        const res = await fetch(\`${baseUrl}${formattedPath}\`);
        const data = await res.json();
        return {
          content: [{ type: "text", text: JSON.stringify(data, null, 2) }]
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: \`Error: \${error.message}\` }]
        };
      }`;
    }
  }
  
  // For POST, PUT, PATCH methods with request body
  if (['POST', 'PUT', 'PATCH'].includes(action.method)) {
    return `try {
        const res = await fetch(\`${baseUrl}${formattedPath}\`, {
          method: "${action.method}",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(args)
        });
        const data = await res.json();
        return {
          content: [{ type: "text", text: JSON.stringify(data, null, 2) }]
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: \`Error: \${error.message}\` }]
        };
      }`;
  }
  
  // For DELETE method
  if (action.method === 'DELETE') {
    return `try {
        const res = await fetch(\`${baseUrl}${formattedPath}\`, {
          method: "DELETE"
        });
        const data = await res.json();
        return {
          content: [{ type: "text", text: JSON.stringify(data, null, 2) }]
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: \`Error: \${error.message}\` }]
        };
      }`;
  }
  
  // Default for any other methods
  return `try {
        const res = await fetch(\`${baseUrl}${formattedPath}\`, {
          method: "${action.method}"
        });
        const data = await res.json();
        return {
          content: [{ type: "text", text: JSON.stringify(data, null, 2) }]
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: \`Error: \${error.message}\` }]
        };
      }`;
} 